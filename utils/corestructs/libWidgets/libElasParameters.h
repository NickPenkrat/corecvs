#ifndef LIBELAS_PARAMETERS_H_
#define LIBELAS_PARAMETERS_H_
/**
 * \file libElasParameters.h
 * \attention This file is automatically generated and should not be in general modified manually
 *
 * \date MMM DD, 20YY
 * \author autoGenerator
 */

#include "reflection.h"
#include "defaultSetter.h"
#include "printerVisitor.h"

/*
 *  Embed includes.
 */
/*
 *  Additional includes for Composite Types.
 */

using namespace core3vi;

/*
 *  Additional includes for Pointer Types.
 */

namespace core3vi {
}
/*
 *  Additional includes for enum section.
 */

/**
 * \brief LibElas Parameters. Supported only in internal builds, due to LIBELAS GPL license 
 * LibElas Parameters. Supported only in internal builds, due to LIBELAS GPL license 
 **/
class LibElasParameters : public BaseReflection<LibElasParameters>
{
public:
    enum FieldId {
        DISP_MIN_ID,
        DISP_MAX_ID,
        SUPPORT_THRESHOLD_ID,
        SUPPORT_TEXTURE_ID,
        CANDIDATE_STEPSIZE_ID,
        INCON_WINDOW_SIZE_ID,
        INCON_THRESHOLD_ID,
        INCON_MIN_SUPPORT_ID,
        ADD_CORNERS_ID,
        GRID_SIZE_ID,
        BETA_ID,
        GAMMA_ID,
        SIGMA_ID,
        S_RADIUS_ID,
        MATCH_TEXTURE_ID,
        L_R_THRESHOLD_ID,
        SPECKLE_SIM_THRESHOLD_ID,
        SPECKLE_SIZE_ID,
        IPOL_GAP_WIDTH_ID,
        FILTER_MEDIAN_ID,
        FILTER_ADAPTIVE_MEAN_ID,
        LIBELAS_PARAMETERS_FIELD_ID_NUM
    };

    /** Section with variables */

    /** 
     * \brief Disp Min 
     * min disparity 
     */
    int mDispMin;

    /** 
     * \brief Disp Max 
     * max disparity 
     */
    int mDispMax;

    /** 
     * \brief Support Threshold 
     * maximum uniqueness ratio best vs second best support match 
     */
    double mSupportThreshold;

    /** 
     * \brief Support Texture 
     * min texture for support points 
     */
    int mSupportTexture;

    /** 
     * \brief Candidate Stepsize 
     * step size of regular grid on which support points are matched 
     */
    int mCandidateStepsize;

    /** 
     * \brief Incon Window Size 
     * window size of inconsistent support point check 
     */
    int mInconWindowSize;

    /** 
     * \brief Incon Threshold 
     * disparity similarity threshold for support point to be considered consistent 
     */
    int mInconThreshold;

    /** 
     * \brief Incon Min Support 
     * minimum number of consistent support points 
     */
    int mInconMinSupport;

    /** 
     * \brief Add Corners 
     * add support points at image corners with nearest neighbor disparities 
     */
    bool mAddCorners;

    /** 
     * \brief Grid Size 
     * size of neighborhood for additional support point extrapolation 
     */
    int mGridSize;

    /** 
     * \brief beta 
     * image likelihood parameter 
     */
    double mBeta;

    /** 
     * \brief gamma 
     * prior constant 
     */
    double mGamma;

    /** 
     * \brief sigma 
     * prior sigma 
     */
    double mSigma;

    /** 
     * \brief S Radius 
     * prior sigma radius 
     */
    double mSRadius;

    /** 
     * \brief Match Texture 
     * min texture for dense matching 
     */
    int mMatchTexture;

    /** 
     * \brief L R Threshold 
     * disparity threshold for left right consistency check 
     */
    int mLRThreshold;

    /** 
     * \brief Speckle Sim Threshold 
     * similarity threshold for speckle segmentation 
     */
    double mSpeckleSimThreshold;

    /** 
     * \brief Speckle Size 
     * maximal size of a speckle. Small speckles get removed 
     */
    int mSpeckleSize;

    /** 
     * \brief Ipol Gap Width 
     * interpolate small gaps 
     */
    int mIpolGapWidth;

    /** 
     * \brief Filter Median 
     * optional median filter approximated 
     */
    bool mFilterMedian;

    /** 
     * \brief Filter Adaptive Mean 
     * optional adaptive mean filter approximated 
     */
    bool mFilterAdaptiveMean;

    /** Static fields init function, this is used for "dynamic" field initialization */ 
    static int staticInit();

    /** Section with getters */
    const void *getPtrById(int fieldId) const
    {
        return (const unsigned char *)(this) + fields()[fieldId]->offset;
    }
    int dispMin() const
    {
        return mDispMin;
    }

    int dispMax() const
    {
        return mDispMax;
    }

    double supportThreshold() const
    {
        return mSupportThreshold;
    }

    int supportTexture() const
    {
        return mSupportTexture;
    }

    int candidateStepsize() const
    {
        return mCandidateStepsize;
    }

    int inconWindowSize() const
    {
        return mInconWindowSize;
    }

    int inconThreshold() const
    {
        return mInconThreshold;
    }

    int inconMinSupport() const
    {
        return mInconMinSupport;
    }

    bool addCorners() const
    {
        return mAddCorners;
    }

    int gridSize() const
    {
        return mGridSize;
    }

    double beta() const
    {
        return mBeta;
    }

    double gamma() const
    {
        return mGamma;
    }

    double sigma() const
    {
        return mSigma;
    }

    double sRadius() const
    {
        return mSRadius;
    }

    int matchTexture() const
    {
        return mMatchTexture;
    }

    int lRThreshold() const
    {
        return mLRThreshold;
    }

    double speckleSimThreshold() const
    {
        return mSpeckleSimThreshold;
    }

    int speckleSize() const
    {
        return mSpeckleSize;
    }

    int ipolGapWidth() const
    {
        return mIpolGapWidth;
    }

    bool filterMedian() const
    {
        return mFilterMedian;
    }

    bool filterAdaptiveMean() const
    {
        return mFilterAdaptiveMean;
    }

    /* Section with setters */
    void setDispMin(int dispMin)
    {
        mDispMin = dispMin;
    }

    void setDispMax(int dispMax)
    {
        mDispMax = dispMax;
    }

    void setSupportThreshold(double supportThreshold)
    {
        mSupportThreshold = supportThreshold;
    }

    void setSupportTexture(int supportTexture)
    {
        mSupportTexture = supportTexture;
    }

    void setCandidateStepsize(int candidateStepsize)
    {
        mCandidateStepsize = candidateStepsize;
    }

    void setInconWindowSize(int inconWindowSize)
    {
        mInconWindowSize = inconWindowSize;
    }

    void setInconThreshold(int inconThreshold)
    {
        mInconThreshold = inconThreshold;
    }

    void setInconMinSupport(int inconMinSupport)
    {
        mInconMinSupport = inconMinSupport;
    }

    void setAddCorners(bool addCorners)
    {
        mAddCorners = addCorners;
    }

    void setGridSize(int gridSize)
    {
        mGridSize = gridSize;
    }

    void setBeta(double beta)
    {
        mBeta = beta;
    }

    void setGamma(double gamma)
    {
        mGamma = gamma;
    }

    void setSigma(double sigma)
    {
        mSigma = sigma;
    }

    void setSRadius(double sRadius)
    {
        mSRadius = sRadius;
    }

    void setMatchTexture(int matchTexture)
    {
        mMatchTexture = matchTexture;
    }

    void setLRThreshold(int lRThreshold)
    {
        mLRThreshold = lRThreshold;
    }

    void setSpeckleSimThreshold(double speckleSimThreshold)
    {
        mSpeckleSimThreshold = speckleSimThreshold;
    }

    void setSpeckleSize(int speckleSize)
    {
        mSpeckleSize = speckleSize;
    }

    void setIpolGapWidth(int ipolGapWidth)
    {
        mIpolGapWidth = ipolGapWidth;
    }

    void setFilterMedian(bool filterMedian)
    {
        mFilterMedian = filterMedian;
    }

    void setFilterAdaptiveMean(bool filterAdaptiveMean)
    {
        mFilterAdaptiveMean = filterAdaptiveMean;
    }

    /* Section with embedded classes */
    /* visitor pattern - http://en.wikipedia.org/wiki/Visitor_pattern */
template<class VisitorType>
    void accept(VisitorType &visitor)
    {
        visitor.visit(mDispMin,                   static_cast<const IntField *>     (fields()[DISP_MIN_ID]));
        visitor.visit(mDispMax,                   static_cast<const IntField *>     (fields()[DISP_MAX_ID]));
        visitor.visit(mSupportThreshold,          static_cast<const DoubleField *>  (fields()[SUPPORT_THRESHOLD_ID]));
        visitor.visit(mSupportTexture,            static_cast<const IntField *>     (fields()[SUPPORT_TEXTURE_ID]));
        visitor.visit(mCandidateStepsize,         static_cast<const IntField *>     (fields()[CANDIDATE_STEPSIZE_ID]));
        visitor.visit(mInconWindowSize,           static_cast<const IntField *>     (fields()[INCON_WINDOW_SIZE_ID]));
        visitor.visit(mInconThreshold,            static_cast<const IntField *>     (fields()[INCON_THRESHOLD_ID]));
        visitor.visit(mInconMinSupport,           static_cast<const IntField *>     (fields()[INCON_MIN_SUPPORT_ID]));
        visitor.visit(mAddCorners,                static_cast<const BoolField *>    (fields()[ADD_CORNERS_ID]));
        visitor.visit(mGridSize,                  static_cast<const IntField *>     (fields()[GRID_SIZE_ID]));
        visitor.visit(mBeta,                      static_cast<const DoubleField *>  (fields()[BETA_ID]));
        visitor.visit(mGamma,                     static_cast<const DoubleField *>  (fields()[GAMMA_ID]));
        visitor.visit(mSigma,                     static_cast<const DoubleField *>  (fields()[SIGMA_ID]));
        visitor.visit(mSRadius,                   static_cast<const DoubleField *>  (fields()[S_RADIUS_ID]));
        visitor.visit(mMatchTexture,              static_cast<const IntField *>     (fields()[MATCH_TEXTURE_ID]));
        visitor.visit(mLRThreshold,               static_cast<const IntField *>     (fields()[L_R_THRESHOLD_ID]));
        visitor.visit(mSpeckleSimThreshold,       static_cast<const DoubleField *>  (fields()[SPECKLE_SIM_THRESHOLD_ID]));
        visitor.visit(mSpeckleSize,               static_cast<const IntField *>     (fields()[SPECKLE_SIZE_ID]));
        visitor.visit(mIpolGapWidth,              static_cast<const IntField *>     (fields()[IPOL_GAP_WIDTH_ID]));
        visitor.visit(mFilterMedian,              static_cast<const BoolField *>    (fields()[FILTER_MEDIAN_ID]));
        visitor.visit(mFilterAdaptiveMean,        static_cast<const BoolField *>    (fields()[FILTER_ADAPTIVE_MEAN_ID]));
    }

    LibElasParameters()
    {
        DefaultSetter setter;
        accept(setter);
    }

    LibElasParameters(
          int dispMin
        , int dispMax
        , double supportThreshold
        , int supportTexture
        , int candidateStepsize
        , int inconWindowSize
        , int inconThreshold
        , int inconMinSupport
        , bool addCorners
        , int gridSize
        , double beta
        , double gamma
        , double sigma
        , double sRadius
        , int matchTexture
        , int lRThreshold
        , double speckleSimThreshold
        , int speckleSize
        , int ipolGapWidth
        , bool filterMedian
        , bool filterAdaptiveMean
    )
    {
        mDispMin = dispMin;
        mDispMax = dispMax;
        mSupportThreshold = supportThreshold;
        mSupportTexture = supportTexture;
        mCandidateStepsize = candidateStepsize;
        mInconWindowSize = inconWindowSize;
        mInconThreshold = inconThreshold;
        mInconMinSupport = inconMinSupport;
        mAddCorners = addCorners;
        mGridSize = gridSize;
        mBeta = beta;
        mGamma = gamma;
        mSigma = sigma;
        mSRadius = sRadius;
        mMatchTexture = matchTexture;
        mLRThreshold = lRThreshold;
        mSpeckleSimThreshold = speckleSimThreshold;
        mSpeckleSize = speckleSize;
        mIpolGapWidth = ipolGapWidth;
        mFilterMedian = filterMedian;
        mFilterAdaptiveMean = filterAdaptiveMean;
    }

    friend ostream& operator << (ostream &out, LibElasParameters &toSave)
    {
        PrinterVisitor printer(out);
        toSave.accept<PrinterVisitor>(printer);
        return out;
    }

    void print ()
    {
        cout << *this;
    }
};
#endif  //LIBELAS_PARAMETERS_H_
