#ifndef ITERATIVE_RECONSTRUCTION_INITIALIZATION_PARAMS_H_
#define ITERATIVE_RECONSTRUCTION_INITIALIZATION_PARAMS_H_
/**
 * \file iterativeReconstructionInitializationParams.h
 * \attention This file is automatically generated and should not be in general modified manually
 *
 * \date MMM DD, 20YY
 * \author autoGenerator
 */

#include "reflection.h"
#include "defaultSetter.h"
#include "printerVisitor.h"

/*
 *  Embed includes.
 */
/*
 *  Additional includes for Composite Types.
 */

using namespace corecvs;

/*
 *  Additional includes for Pointer Types.
 */

namespace corecvs {
}
/*
 *  Additional includes for enum section.
 */

/**
 * \brief Iterative Reconstruction Initialization Params 
 * Iterative Reconstruction Initialization Params 
 **/
class IterativeReconstructionInitializationParams : public BaseReflection<IterativeReconstructionInitializationParams>
{
public:
    enum FieldId {
        B2BRANSACP5RPTHRESHOLD_ID,
        INLIERP5RPTHRESHOLD_ID,
        MAXESSENTIALRANSACITERATIONS_ID,
        B2BRANSACP6RPTHRESHOLD_ID,
        RUNESSENTIALFILTERING_ID,
        ESSENTIALTARGETGAMMA_ID,
        MAXP6RPITERATIONS_ID,
        INLIERP6RPTHRESHOLD_ID,
        GAMMAP6RP_ID,
        ITERATIVE_RECONSTRUCTION_INITIALIZATION_PARAMS_FIELD_ID_NUM
    };

    /** Section with variables */

    /** 
     * \brief b2bRansacP5RPThreshold 
     * Best-2nd best essential estimator threshold 
     */
    double mB2bRansacP5RPThreshold;

    /** 
     * \brief inlierP5RPThreshold 
     * Inlier threshold 
     */
    double mInlierP5RPThreshold;

    /** 
     * \brief maxEssentialRansacIterations 
     * Maximal essential estimator rounds 
     */
    int mMaxEssentialRansacIterations;

    /** 
     * \brief b2bRansacP6RPThreshold 
     * Best-2nd best relative pose estimator threshold 
     */
    double mB2bRansacP6RPThreshold;

    /** 
     * \brief runEssentialFiltering 
     * Run essential filtering prior relative pose estimation 
     */
    bool mRunEssentialFiltering;

    /** 
     * \brief essentialTargetGamma 
     * essentialTargetGamma 
     */
    double mEssentialTargetGamma;

    /** 
     * \brief maxP6RPIterations 
     * Maximal number of ransac iterations for pose estimation using pairwise correspondences 
     */
    int mMaxP6RPIterations;

    /** 
     * \brief inlierP6RPThreshold 
     * Inlier threshold for pose estimation using pairwise correspondences 
     */
    double mInlierP6RPThreshold;

    /** 
     * \brief gammaP6RP 
     * Target failure probability for pose estimation 
     */
    double mGammaP6RP;

    /** Static fields init function, this is used for "dynamic" field initialization */ 
    static int staticInit();

    /** Section with getters */
    const void *getPtrById(int fieldId) const
    {
        return (const unsigned char *)(this) + fields()[fieldId]->offset;
    }
    double b2bRansacP5RPThreshold() const
    {
        return mB2bRansacP5RPThreshold;
    }

    double inlierP5RPThreshold() const
    {
        return mInlierP5RPThreshold;
    }

    int maxEssentialRansacIterations() const
    {
        return mMaxEssentialRansacIterations;
    }

    double b2bRansacP6RPThreshold() const
    {
        return mB2bRansacP6RPThreshold;
    }

    bool runEssentialFiltering() const
    {
        return mRunEssentialFiltering;
    }

    double essentialTargetGamma() const
    {
        return mEssentialTargetGamma;
    }

    int maxP6RPIterations() const
    {
        return mMaxP6RPIterations;
    }

    double inlierP6RPThreshold() const
    {
        return mInlierP6RPThreshold;
    }

    double gammaP6RP() const
    {
        return mGammaP6RP;
    }

    /* Section with setters */
    void setB2bRansacP5RPThreshold(double b2bRansacP5RPThreshold)
    {
        mB2bRansacP5RPThreshold = b2bRansacP5RPThreshold;
    }

    void setInlierP5RPThreshold(double inlierP5RPThreshold)
    {
        mInlierP5RPThreshold = inlierP5RPThreshold;
    }

    void setMaxEssentialRansacIterations(int maxEssentialRansacIterations)
    {
        mMaxEssentialRansacIterations = maxEssentialRansacIterations;
    }

    void setB2bRansacP6RPThreshold(double b2bRansacP6RPThreshold)
    {
        mB2bRansacP6RPThreshold = b2bRansacP6RPThreshold;
    }

    void setRunEssentialFiltering(bool runEssentialFiltering)
    {
        mRunEssentialFiltering = runEssentialFiltering;
    }

    void setEssentialTargetGamma(double essentialTargetGamma)
    {
        mEssentialTargetGamma = essentialTargetGamma;
    }

    void setMaxP6RPIterations(int maxP6RPIterations)
    {
        mMaxP6RPIterations = maxP6RPIterations;
    }

    void setInlierP6RPThreshold(double inlierP6RPThreshold)
    {
        mInlierP6RPThreshold = inlierP6RPThreshold;
    }

    void setGammaP6RP(double gammaP6RP)
    {
        mGammaP6RP = gammaP6RP;
    }

    /* Section with embedded classes */
    /* visitor pattern - http://en.wikipedia.org/wiki/Visitor_pattern */
template<class VisitorType>
    void accept(VisitorType &visitor)
    {
        visitor.visit(mB2bRansacP5RPThreshold,    static_cast<const DoubleField *>  (fields()[B2BRANSACP5RPTHRESHOLD_ID]));
        visitor.visit(mInlierP5RPThreshold,       static_cast<const DoubleField *>  (fields()[INLIERP5RPTHRESHOLD_ID]));
        visitor.visit(mMaxEssentialRansacIterations, static_cast<const IntField *>     (fields()[MAXESSENTIALRANSACITERATIONS_ID]));
        visitor.visit(mB2bRansacP6RPThreshold,    static_cast<const DoubleField *>  (fields()[B2BRANSACP6RPTHRESHOLD_ID]));
        visitor.visit(mRunEssentialFiltering,     static_cast<const BoolField *>    (fields()[RUNESSENTIALFILTERING_ID]));
        visitor.visit(mEssentialTargetGamma,      static_cast<const DoubleField *>  (fields()[ESSENTIALTARGETGAMMA_ID]));
        visitor.visit(mMaxP6RPIterations,         static_cast<const IntField *>     (fields()[MAXP6RPITERATIONS_ID]));
        visitor.visit(mInlierP6RPThreshold,       static_cast<const DoubleField *>  (fields()[INLIERP6RPTHRESHOLD_ID]));
        visitor.visit(mGammaP6RP,                 static_cast<const DoubleField *>  (fields()[GAMMAP6RP_ID]));
    }

    IterativeReconstructionInitializationParams()
    {
        DefaultSetter setter;
        accept(setter);
    }

    IterativeReconstructionInitializationParams(
          double b2bRansacP5RPThreshold
        , double inlierP5RPThreshold
        , int maxEssentialRansacIterations
        , double b2bRansacP6RPThreshold
        , bool runEssentialFiltering
        , double essentialTargetGamma
        , int maxP6RPIterations
        , double inlierP6RPThreshold
        , double gammaP6RP
    )
    {
        mB2bRansacP5RPThreshold = b2bRansacP5RPThreshold;
        mInlierP5RPThreshold = inlierP5RPThreshold;
        mMaxEssentialRansacIterations = maxEssentialRansacIterations;
        mB2bRansacP6RPThreshold = b2bRansacP6RPThreshold;
        mRunEssentialFiltering = runEssentialFiltering;
        mEssentialTargetGamma = essentialTargetGamma;
        mMaxP6RPIterations = maxP6RPIterations;
        mInlierP6RPThreshold = inlierP6RPThreshold;
        mGammaP6RP = gammaP6RP;
    }

    friend ostream& operator << (ostream &out, IterativeReconstructionInitializationParams &toSave)
    {
        PrinterVisitor printer(out);
        toSave.accept<PrinterVisitor>(printer);
        return out;
    }

    void print ()
    {
        cout << *this;
    }
};
#endif  //ITERATIVE_RECONSTRUCTION_INITIALIZATION_PARAMS_H_
