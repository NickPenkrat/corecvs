/**
 * \file iterativeReconstructionAppendParams.cpp
 * \attention This file is automatically generated and should not be in general modified manually
 *
 * \date MMM DD, 20YY
 * \author autoGenerator
 */

#include <vector>
#include <stddef.h>
#include "iterativeReconstructionAppendParams.h"

/**
 *  Looks extremely unsafe because it depends on the order of static initialization.
 *  Should check standard if this is ok
 *
 *  Also it's not clear why removing "= Reflection()" breaks the code;
 **/

namespace corecvs {
template<>
Reflection BaseReflection<IterativeReconstructionAppendParams>::reflection = Reflection();
template<>
int BaseReflection<IterativeReconstructionAppendParams>::dummy = IterativeReconstructionAppendParams::staticInit();
} // namespace corecvs 

SUPPRESS_OFFSET_WARNING_BEGIN

int IterativeReconstructionAppendParams::staticInit()
{

    ReflectionNaming &nameing = naming();
    nameing = ReflectionNaming(
        "Iterative Reconstruction Append Params",
        "Iterative Reconstruction Append Params",
        ""
    );

     getReflection()->objectSize = sizeof(IterativeReconstructionAppendParams);
     

    BoolField* field0_ = new BoolField
        (
          IterativeReconstructionAppendParams::ALLOWSUPERSPECULATIVEAPPEND_ID,
          offsetof(IterativeReconstructionAppendParams, mAllowSuperSpeculativeAppend),
          false,
          "allowSuperSpeculativeAppend",
          "allowSuperSpeculativeAppend",
          "If you have lots of correct feature matches (>500 for each pair), than you may try super-speculative appending"
        );
    field0_->widgetHint=BaseField::CHECK_BOX;
    fields().push_back(field0_);

    IntField* field0 = new IntField
        (
          IterativeReconstructionAppendParams::POSTAPPENDOPTIMIZATIONWINDOW_ID,
          offsetof(IterativeReconstructionAppendParams, mPostAppendOptimizationWindow),
          -1,
          "postAppendOptimizationWindow",
          "postAppendOptimizationWindow",
          "Maximal number of fixtures being optimized after append",
          true,
         -1,
         1000000
        );
    fields().push_back(field0);
    /*  */ 
    IntField* field1 = new IntField
        (
          IterativeReconstructionAppendParams::MAXPOSTAPPEND_ID,
          offsetof(IterativeReconstructionAppendParams, mMaxPostAppend),
          2,
          "maxPostAppend",
          "maxPostAppend",
          "Maximal post-append iterations",
          true,
         1,
         100000
        );
    fields().push_back(field1);
    /*  */ 
    DoubleField* field2 = new DoubleField
        (
          IterativeReconstructionAppendParams::INLIERP3PTHRESHOLD_ID,
          offsetof(IterativeReconstructionAppendParams, mInlierP3PThreshold),
          2,
          "inlierP3PThreshold",
          "inlierP3PThreshold",
          "Inlier threshold for 3P->pose",
          true,
         0,
         10000
        );
    field2->widgetHint=BaseField::SPIN_BOX;
    field2->precision=6;
    fields().push_back(field2);
    /*  */ 
    IntField* field3 = new IntField
        (
          IterativeReconstructionAppendParams::MAXP3PITERATIONS_ID,
          offsetof(IterativeReconstructionAppendParams, mMaxP3PIterations),
          100000,
          "maxP3PIterations",
          "maxP3PIterations",
          "Maximal ransac iterations for 3P->pose",
          true,
         1,
         1000000
        );
    fields().push_back(field3);
    /*  */ 
    DoubleField* field4 = new DoubleField
        (
          IterativeReconstructionAppendParams::GAMMAP3P_ID,
          offsetof(IterativeReconstructionAppendParams, mGammaP3P),
          0.001,
          "gammaP3P",
          "gammaP3P",
          "Target error probability for 3P pose estimation",
          true,
         0,
         1
        );
    field4->widgetHint=BaseField::SPIN_BOX;
    field4->precision=6;
    fields().push_back(field4);
    /*  */ 
    DoubleField* field5 = new DoubleField
        (
          IterativeReconstructionAppendParams::INLIERP6PTHRESHOLD_ID,
          offsetof(IterativeReconstructionAppendParams, mInlierP6PThreshold),
          1,
          "inlierP6PThreshold",
          "inlierP6PThreshold",
          "Inlier threshold for 6P->pose/3P->orientation",
          true,
         0,
         10000
        );
    field5->widgetHint=BaseField::SPIN_BOX;
    field5->precision=6;
    fields().push_back(field5);
    /*  */ 
    IntField* field6 = new IntField
        (
          IterativeReconstructionAppendParams::MAXP6PITERATIONS_ID,
          offsetof(IterativeReconstructionAppendParams, mMaxP6PIterations),
          400000,
          "maxP6PIterations",
          "maxP6PIterations",
          "Maximal ransac iterations for 6P->pose/3P->orientation",
          true,
         1,
         1000000
        );
    fields().push_back(field6);
    /*  */ 
    DoubleField* field7 = new DoubleField
        (
          IterativeReconstructionAppendParams::GAMMAP6P_ID,
          offsetof(IterativeReconstructionAppendParams, mGammaP6P),
          0.001,
          "gammaP6P",
          "gammaP6P",
          "Target error probability for 6P->pose/3P->orientation",
          true,
         0,
         1
        );
    field7->widgetHint=BaseField::SPIN_BOX;
    field7->precision=6;
    fields().push_back(field7);
    /*  */ 
    IntField* field8 = new IntField
        (
          IterativeReconstructionAppendParams::SPECULATIVITY_ID,
          offsetof(IterativeReconstructionAppendParams, mSpeculativity),
          1000,
          "speculativity",
          "speculativity",
          "This defines how many multicameras are subject for P3P evaluation at each iteration",
          true,
         1,
         1000000
        );
    fields().push_back(field8);
    /*  */ 
    IntField* field9 = new IntField
        (
          IterativeReconstructionAppendParams::MINIMALINLIERCOUNT_ID,
          offsetof(IterativeReconstructionAppendParams, mMinimalInlierCount),
          32,
          "minimalInlierCount",
          "minimalInlierCount",
          "Minimal inlier count for hypotheis acceptance",
          true,
         3,
         1000000
        );
    fields().push_back(field9);
    /*  */ 
    DoubleField* field10 = new DoubleField
        (
          IterativeReconstructionAppendParams::MAXIMALFAILUREPROBABILITY_ID,
          offsetof(IterativeReconstructionAppendParams, mMaximalFailureProbability),
          0.15,
          "maximalFailureProbability",
          "maximalFailureProbability",
          "Maximal failure probability for hypothesis acceptance",
          true,
         0,
         1
        );
    field10->widgetHint=BaseField::SPIN_BOX;
    field10->precision=6;
    fields().push_back(field10);
    /*  */ 
    IntField* field11 = new IntField
        (
          IterativeReconstructionAppendParams::SHUTUPANDAPPENDMYFIXTUREINLIERTHRESHOLD_ID,
          offsetof(IterativeReconstructionAppendParams, mShutUpAndAppendMyFixtureInlierThreshold),
          200,
          "shutUpAndAppendMyFixtureInlierThreshold",
          "shutUpAndAppendMyFixtureInlierThreshold",
          "Immediate append inlier count threshold",
          true,
         10,
         1000000
        );
    fields().push_back(field11);
    /*  */ 
    DoubleField* field12 = new DoubleField
        (
          IterativeReconstructionAppendParams::SHUTUPANDAPPENDMYFIXTURESUCCESSPROBTHRESHOLD_ID,
          offsetof(IterativeReconstructionAppendParams, mShutUpAndAppendMyFixtureSuccessProbThreshold),
          0.9,
          "shutUpAndAppendMyFixtureSuccessProbThreshold",
          "shutUpAndAppendMyFixtureSuccessProbThreshold",
          "shutUpAndAppendMyFixtureSuccessProbThreshold",
          true,
         0,
         1
        );
    field12->widgetHint=BaseField::SPIN_BOX;
    field12->precision=6;
    fields().push_back(field12);
    /*  */ 
    ReflectionDirectory &directory = *ReflectionDirectoryHolder::getReflectionDirectory();
    directory[std::string("Iterative Reconstruction Append Params")]= &reflection;
   return 0;
}

SUPPRESS_OFFSET_WARNING_END


